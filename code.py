# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11kHaH_ti33F-0t729hEl5uef_3_O09sZ
"""

from google.colab import drive
import numpy as np
import cv2
import math
import matplotlib.pyplot as plt


# index of target and source images given in file names
index = ["01", "02", "03", "05", "06", "08", "09", "11", "15", "20", "24", "29", "50", "51", "56"]
# paths of input images stored and output images will be saved
dataPath = "/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/data/"
resultPath = "/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/results/"
croppedSourcePath = "/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/cropped_source/"
croppedTargetPath = "/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/cropped_target/"
croppedTransferredPath = "/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/cropped_transferred/"
histogramPath = "/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/histograms/"
# prefixes of images
sourcePrefix = "in_"
targetPrefix = "tar_"
resultPrefix = "res_"
# file extension of images
fileExtension = ".png"


# reads image source and target images and returns in RGB color space.
def read_file(index):
	s = cv2.imread(dataPath+sourcePrefix+index+fileExtension)
	t = cv2.imread(dataPath+targetPrefix+index+fileExtension)

	return cv2.cvtColor(s, cv2.COLOR_BGR2RGB), cv2.cvtColor(t, cv2.COLOR_BGR2RGB)
 

# takes image in RGB color space and returns in LMS color space. To satisfy the logarithm condition,values equal to 0 are set as 1.
def RGB2LMS(img):
  mtx = np.array([[0.3811,0.5783,0.0402],
         [0.1967,0.7244,0.0782],
         [0.0241,0.1288,0.8444]])
  
  # image in LMS space
  img_LMS = np.matmul(img, mtx.T)

  # set values equal to 0, as 1
  img_LMS[img_LMS == float(0)] = 1
  img_LMS = np.log10(img_LMS)

  return  img_LMS

# takes image in RGB color space and returns in LAB color space. 
def RGB2LAB(img):
    img_LMS = RGB2LMS(img)
    mtx = np.matmul([[1/np.sqrt(3),0,0],[0,1/np.sqrt(6),0],[0,0,1/np.sqrt(2)]], [[1,1,1],[1,1,-2],[1,-1,0]])

    return  np.matmul(img_LMS, mtx.T)

# takes image in LAB color space and returns in RGB color space. 
def LAB2RGB(img):
    mtx = np.matmul([[1,1,1],
            [1,1,-1],
            [1,-2,0]], [[np.sqrt(3)/3,0,0],
            [0,np.sqrt(6)/6,0],
            [0,0,np.sqrt(2)/2]])
    img_LMS = np.power(10, np.matmul(img, mtx.T))

    return LMS2RGB(img_LMS)


# takes image in LMS color space and returns in RGB color space. 
def LMS2RGB(img):
    mtx = np.array([[4.4679,-3.5873,0.1193],
          [-1.2186,2.3809,-0.1624],
          [0.0497,-0.2439,1.2045]])

    return np.matmul(img, mtx.T)

# returns the mean and standard deviation values of the input image.
def get_mean_and_std(x):
	return cv2.meanStdDev(x)
 
# transfer colors using method of Reinhard et al. First RGB images turn into LAB color space for color transfering then RGB color space back.
# Save results into the given result path.
def color_transfer():
  for n in index:
    s, t = read_file(n)
  
    s = RGB2LAB(s)
    t = RGB2LAB(t)

    s_mean, s_std = get_mean_and_std(s)
    t_mean, t_std = get_mean_and_std(t)


    for i in range(0,3):
      s[:,:,i] = ((s[:,:,i] - s_mean[i])*(t_std[i]/(s_std[i]))) + t_mean[i]

    s = LAB2RGB(s)
    #Reducing outliers, more than 255 and less than 0
    s[s < 0] = 0
    s[s> 255] = 255


    s = cv2.cvtColor(np.uint8(s), cv2.COLOR_RGB2BGR)

    cv2.imwrite("/content/drive/MyDrive/Colab Notebooks/BBM415-Assignment2/results_unhandled_tresholds/"+resultPrefix +n+'.png',s)

def color_transferPart2(s, t):

  s = RGB2LAB(cv2.cvtColor(s, cv2.COLOR_BGR2RGB))
  t = RGB2LAB(cv2.cvtColor(t, cv2.COLOR_BGR2RGB))

  s_mean, s_std = get_mean_and_std(s)
  t_mean, t_std = get_mean_and_std(t)


  for i in range(0,3):
    s[:,:,i] = ((s[:,:,i] - s_mean[i])*(t_std[i]/(s_std[i]))) + t_mean[i]

  s = LAB2RGB(s)
  #Reducing outliers, more than 255 and less than 0
  s[s < 0] = 0
  s[s> 255] = 255


  return cv2.cvtColor(np.uint8(s), cv2.COLOR_RGB2BGR)

# run the color transfer algorithm
color_transfer()

# Calculate the normalized correlation coefficient between two same size of array
def NCC(x, y):
  x = np.ndarray.flatten(x)
  y = np.ndarray.flatten(y)
  return np.dot(x / np.linalg.norm(x), y / np.linalg.norm(y))


# crop image into cropX*cropY parts. 
# cropX states number of crops will be done on width 
# cropy states number of crops will be done on height
def cropImg(index, cropX, cropY):
  piece = 0
  s = cv2.imread(dataPath+sourcePrefix+index+fileExtension)
  t = cv2.imread(dataPath+targetPrefix+index+fileExtension)

  sDim = s.shape
  tDim = t.shape

  #Reshaping the images since NCC algorithm runs on images has same size
  wMin = min(sDim[0], tDim[0])
  hMin = min(sDim[1], tDim[1])

  s = s[(sDim[0] - wMin ) : , (sDim[1]-hMin ) :]
  t = t[(tDim[0] - wMin ) : , (tDim[1]-hMin ) :]
  #print("s shape : ",s.shape)
  #print("t shape : ",t.shape)

  width = wMin // cropX
  height = hMin // cropY


  for x in range(1, cropX+1):
    for y in range(1,cropY+1):
      sPiece = s[(x-1)*width : x*width, (y-1)*height: y*height]
      tPiece = t[(x-1)*width : x*width, (y-1)*height: y*height]

      cv2.imwrite(croppedSourcePath+sourcePrefix +index + "_" + str(piece) +'.png',sPiece)
      cv2.imwrite(croppedTargetPath+targetPrefix +index + "_" + str(piece) +'.png',tPiece)
      piece += 1


def mergeImg(index, w, h):

  count = w*h
  nccArray = np.zeros(count, dtype = int)

  for x in range(0,count):
    nccMax = -1;
    for y in range(0, count):
      src = cv2.imread(croppedSourcePath+sourcePrefix +index + "_" + str(x) +'.png')
      tar = cv2.imread(croppedTargetPath+targetPrefix +index + "_" + str(y) +'.png')
      print("src shape: ", src.shape)
      print("star shape: " ,tar.shape)
      ncc_result = NCC(src,tar)
      if ncc_result > nccMax:
        nccMax = ncc_result
        nccArray[x] = y

  imgArr = np.zeros((count, src.shape[0], src.shape[1], src.shape[2]))
  for i in range(0,count):
      src = cv2.imread(croppedSourcePath+sourcePrefix +index + "_" + str(i) +'.png')
      tar = cv2.imread(croppedTargetPath+targetPrefix +index + "_" + str(nccArray[i]) +'.png')
      imgArr[i] = color_transferPart2(src, tar)


  rows = [cv2.hconcat([imgArr[x] for x in range(w*i,w*(i+1))]) for i in range(0,h)]

  cv2.imwrite(croppedTransferredPath+targetPrefix +index +'.png',cv2.vconcat(rows))


for i in index:
  cropImg(i, 2, 2)

for i in index:
  mergeImg(i, 2, 2)


def plot_histograms(img,n):

    image = cv2.imread(img)
    vals = image.mean(axis=2).flatten()
    # plot histogram with 255 bins
    b, bins, patches = plt.hist(vals, 255)
    plt.xlim([0,255])
    plt.ylabel('Counts')
    plt.xlabel('Intensity')

    plt.savefig(histogramPath +  n + '.png')
    plt.close()
    plt.cla()

plot_histograms(croppedTransferredPath+targetPrefix +"05" +'.png' , "4_05")
plot_histograms(dataPath+sourcePrefix +"05" +'.png' , "1_05")
plot_histograms(dataPath+targetPrefix +"05" +'.png' , "2_05")
plot_histograms(resultPath+resultPrefix  +"05" +'.png' , "3_05")